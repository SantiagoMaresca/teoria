\section{Estructura de datos}
Se representa el arbol-kdr mediante tuplas anidadas, donde cada
nodo interno es una tupla de orden $2^r + 1$, y los externos (hojas)
son de orden 1.

Para asignar un subarbol a cada nodo se realiza una bipartición por
cada dimensión, hayando la mediana si se ordena el conjunto por cada
una de las r dimensiones de ese nivel, y comparando la i-ésima
dimensión con la mediana segun el orden por ella.
De esta forma el primer árbol tendra a los nodos cuya primer
dimensión es menor a la (primer) mediana, y cuya segunda dimensión
es también menor a la mediana, y así para cada una de las r
dimensiones consideradas, siempre ``menor''.

Podemos representar con una cadena de largo r el
criterio de cada subarbol. El primero sería ``$<<<$'' si consideramos
r = 3. El segundo subárbol tendría el criterio ``$<<\geq$''.

Si imaginamos un mapeo del alfabeto $\Sigma = \{ <, \geq \}$ al
alfabeto binario $\{ 0, 1 \}$ podemos considerar el orden numérico
que corresponde a ellos: 00, 01, 10, 11 (para largo 2).
Si
listamos la cadena de cada uno de los subárboles con r =2 estas son,
en el órden en que aparecen los subárboles, ``$<<$'', ``$<\geq$'',
``$\geq<$'', ``$\geq\geq$''.

Así la tupla de los nodos internos tiene la forma (raiz, subarbol1,
subarbol2, ...), siguiendo cada subárbol el criterio definido.



\section{Armado de un Árbol-KDR}
\subsection{Obtención de las medianas}
\lstinputlisting[firstline=29,lastline=36,language=Python,caption={\call{getMedians}}]{kdstruct.py}

El bucle de la linea 4 realiza r iteraciones. El \call{map} de la linea 5 es
\emph{perezoso}, por lo que su costo (cada aplicación es \BigO{1}) se une al de
armar un set, que es \BigO{n}. Esto para quitar duplicados.
Finalmente pasarlo a una lista es a su vez \BigO{n}.

Ordenarlo como en la linea 6 tiene un orden \BigO{n \log{n}}, y la inserción de
la linea 7 tiene orden \BigO{1}.

Asi el orden de la función \call{getMedians} es:

\[ r \cdot (\BigO{n}+\BigO{n}+\BigO{n \log{n}} + \BigO{1}) \\
   = r \cdot \BigO{n \log{n}}  \]

\subsection{Comparación del criterio}
\lstinputlisting[firstline=38,lastline=46,language=Python,caption={\call{matches\_criteria}}]{kdstruct.py}

\call{criteria} es un vector que tiene cada combinación de \(\{ T, F \}\),
tomadas de a \(r\), por lo que tiene un largo de \(2^r\). \call{enumerate}
tambien es perezoso, y en cada paso tiene costo \BigO{1}.

El cuerpo del \call{for} tiene costo \BigO{1}. Por lo que el orden de la función es:

\[ 2^r \cdot \BigO{1} \]


\subsection{Armado del árbol}
\lstinputlisting[firstline=48,lastline=68,language=Python,caption={\call{makeKDRTree}}]{kdstruct.py}


\textbf{Orden de tiempo de ejecución del algoritmo:}
\begin{description}
\item[Mejor de los casos:] points es nulo o es una tupla de largo uno.
  El algoritmo tendrá orden de ejecución : \BigO{1}.
\item[Caso promedio:] \BigO{n}
\end{description}



\section{Búsqueda de un Árbol-KDR}
\lstinputlisting[firstline=69,lastline=84,language=Python,caption={\call{getMedians}}]{kdstruct.py}


\textbf{Orden de tiempo de ejecución del algoritmo:}
\begin{description}
\item[Mejor de los casos:] El arbol es nulo o es tiene un único ``nodo''.
  El algoritmo tendrá orden de ejecución : \BigO{1}.
\item[Caso promedio:] \(T(n)= 2^r (T(n/2^r)+ O(r))\).
\end{description}

